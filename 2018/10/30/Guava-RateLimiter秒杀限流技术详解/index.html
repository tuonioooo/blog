<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    
    <title>Guava-RateLimiter秒杀限流技术详解 | 代东泽</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
    <meta name="description" content="使用场景系统使用下游资源时，需要考虑下游对资源受限、处理能力，在下游资源无法或者短时间内无法提升处理性能的情况下，可以使用限流器或者类似保护机制，避免下游服务崩溃造成整体服务的不可用。 常用算法常见限流算法有两种：漏桶算法和令牌桶算法。 漏桶算法具体问题 网站的访问ip中，找出进行频繁连接的ip，并对这些ip的访问频率进行限制。 解决方案 Leak Bucket / Token Bucket 学习">
<meta name="keywords" content="高并发,秒杀,限流">
<meta property="og:type" content="article">
<meta property="og:title" content="Guava-RateLimiter秒杀限流技术详解">
<meta property="og:url" content="https://pentakillandquadrakill.gitee.io/blog/2018/10/30/Guava-RateLimiter秒杀限流技术详解/index.html">
<meta property="og:site_name" content="代东泽">
<meta property="og:description" content="使用场景系统使用下游资源时，需要考虑下游对资源受限、处理能力，在下游资源无法或者短时间内无法提升处理性能的情况下，可以使用限流器或者类似保护机制，避免下游服务崩溃造成整体服务的不可用。 常用算法常见限流算法有两种：漏桶算法和令牌桶算法。 漏桶算法具体问题 网站的访问ip中，找出进行频繁连接的ip，并对这些ip的访问频率进行限制。 解决方案 Leak Bucket / Token Bucket 学习">
<meta property="og:locale" content="default">
<meta property="og:image" content="http://blog.51cto.com/attachment/201205/223552670.jpg">
<meta property="og:image" content="c:/Users/tony/Desktop/2323.png">
<meta property="og:image" content="https:////upload-images.jianshu.io/upload_images/2121202-e978395e51b3d0c3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp">
<meta property="og:image" content="https:////upload-images.jianshu.io/upload_images/2121202-b60565b4e4579927.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp">
<meta property="og:image" content="https:////upload-images.jianshu.io/upload_images/2121202-b6953207d57818bb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp">
<meta property="og:updated_time" content="2018-10-30T03:14:53.135Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Guava-RateLimiter秒杀限流技术详解">
<meta name="twitter:description" content="使用场景系统使用下游资源时，需要考虑下游对资源受限、处理能力，在下游资源无法或者短时间内无法提升处理性能的情况下，可以使用限流器或者类似保护机制，避免下游服务崩溃造成整体服务的不可用。 常用算法常见限流算法有两种：漏桶算法和令牌桶算法。 漏桶算法具体问题 网站的访问ip中，找出进行频繁连接的ip，并对这些ip的访问频率进行限制。 解决方案 Leak Bucket / Token Bucket 学习">
<meta name="twitter:image" content="http://blog.51cto.com/attachment/201205/223552670.jpg">
    

    

    

    <link rel="stylesheet" href="/blog/vendor/font-awesome/css/font-awesome.min.css">
    <link rel="stylesheet" href="/blog/vendor/open-sans/styles.css">
    <link rel="stylesheet" href="/blog/vendor/source-code-pro/styles.css">

    <link rel="stylesheet" href="/blog/css/style.css">

    <script src="/blog/vendor/jquery/2.1.3/jquery.min.js"></script>
    
    
        <link rel="stylesheet" href="/blog/vendor/lightgallery/css/lightgallery.min.css">
    
    
    
    
    


</head>

<body>
    <div id="container">
        <header id="header">
    <div id="header-main" class="header-inner">
        <div class="outer">
            <a href="/blog/" id="logo">
                <i class="logo"></i>
                <span class="site-title">代东泽</span>
            </a>
            <nav id="main-nav">
                
                    <a class="main-nav-link" href="/blog/.">Home</a>
                
                    <a class="main-nav-link" href="/blog/archives">Archives</a>
                
                    <a class="main-nav-link" href="/blog/categories">Categories</a>
                
                    <a class="main-nav-link" href="/blog/tags">Tags</a>
                
                    <a class="main-nav-link" href="/blog/about">About</a>
                
            </nav>
            
                
                <nav id="sub-nav">
                    <div class="profile" id="profile-nav">
                        <a id="profile-anchor" href="javascript:;">
                            <img class="avatar" src="/blog/css/images/qrcode.png" />
                            <i class="fa fa-caret-down"></i>
                        </a>
                    </div>
                </nav>
            
            <div id="search-form-wrap">

    <form class="search-form">
        <input type="text" class="ins-search-input search-form-input" placeholder="Rechercher" />
        <button type="submit" class="search-form-submit"></button>
    </form>
    <div class="ins-search">
    <div class="ins-search-mask"></div>
    <div class="ins-search-container">
        <div class="ins-input-wrapper">
            <input type="text" class="ins-search-input" placeholder="Type something..." />
            <span class="ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: 'Articles',
            PAGES: 'Pages',
            CATEGORIES: 'Catégories',
            TAGS: 'Tags',
            UNTITLED: '(Untitled)',
        },
        ROOT_URL: '/blog/',
        CONTENT_URL: '/blog/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>
<script src="/blog/js/insight.js"></script>

</div>
        </div>
    </div>
    <div id="main-nav-mobile" class="header-sub header-inner">
        <table class="menu outer">
            <tr>
                
                    <td><a class="main-nav-link" href="/blog/.">Home</a></td>
                
                    <td><a class="main-nav-link" href="/blog/archives">Archives</a></td>
                
                    <td><a class="main-nav-link" href="/blog/categories">Categories</a></td>
                
                    <td><a class="main-nav-link" href="/blog/tags">Tags</a></td>
                
                    <td><a class="main-nav-link" href="/blog/about">About</a></td>
                
                <td>
                    
    <div class="search-form">
        <input type="text" class="ins-search-input search-form-input" placeholder="Rechercher" />
    </div>

                </td>
            </tr>
        </table>
    </div>
</header>

        <div class="outer">
            
                

<aside id="profile">
    <div class="inner profile-inner">
        <div class="base-info profile-block">
            <img id="avatar" src="/blog/css/images/qrcode.png" />
			<small style="font-size: 13px;color:#808080ad;display: block;" align="center">学习是一种信仰</small>
			<br/>
			<h2 id="name">IT技术知识博客园</h2>
            <h3 id="title"></h3>
			<!--
			地址
            <span id="location"><i class="fa fa-map-marker"></i></span>
			-->
			<!-- 
			<a id="follow" target="_blank" href="https://github.com/ppoffice/">SUIVRE</a>
			-->
			<a id="follow" target="_blank" href="https://github.com/ppoffice/">扫描二维码关注我</a>
        </div>
        <!-- 
		<div class="article-info profile-block">
            <div class="article-info-block">
                10
                <span>Articles</span>
            </div>
            <div class="article-info-block">
                7
                <span>Tags</span>
            </div>
        </div>
		-->
        
        <div class="profile-block social-links">
            <table>
                <tr>
                    
                    
                    <td>
                        <a href="https://github.com/tuonioooo" target="_blank" title="github" class=tooltip>
                            <i class="fa fa-github"></i>
                        </a>
                    </td>
                    
                    <td>
                        <a href="/blog/" target="_blank" title="gitee" class=tooltip>
                            <i class="fa fa-gitee"></i>
                        </a>
                    </td>
                    
                </tr>
            </table>
        </div>
        
    </div>
</aside>

            
            <section id="main"><article id="post-Guava-RateLimiter秒杀限流技术详解" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
    
        <h1 class="article-title" itemprop="name">
            Guava-RateLimiter秒杀限流技术详解
        </h1>
    

                
                    <div class="article-meta">
						
    <span class="label label-warning" style="float: left;padding: 3px 5px 3px 5px;margin-right: 15px;">转载</span>

						
    <div class="article-date">
        <i class="fa fa-calendar"></i>
        <a href="/blog/2018/10/30/Guava-RateLimiter秒杀限流技术详解/">
            <time datetime="2018-10-30T02:26:28.000Z" itemprop="datePublished">2018-10-30</time>
        </a>
    </div>


                        
	<div class="article-category" style="text-transform: none;">
    	<i class="fa fa-user"></i>
        代东泽
    </div>
    <div class="article-category">
    	<i class="fa fa-folder"></i>
        <a class="article-category-link" href="/blog/categories/Java/">Java</a>
    </div>

                        
    <div class="article-tag">
        <i class="fa fa-tag"></i>
        <a class="tag-link" href="/blog/tags/秒杀/">秒杀</a>, <a class="tag-link" href="/blog/tags/限流/">限流</a>, <a class="tag-link" href="/blog/tags/高并发/">高并发</a>
    </div>

                    </div>
                
            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
            
            <h1 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h1><p>系统使用下游资源时，需要考虑下游对资源受限、处理能力，在下游资源无法或者短时间内无法提升处理性能的情况下，可以使用限流器或者类似保护机制，避免下游服务崩溃造成整体服务的不可用。</p>
<h1 id="常用算法"><a href="#常用算法" class="headerlink" title="常用算法"></a>常用算法</h1><p>常见限流算法有两种：漏桶算法和令牌桶算法。</p>
<h3 id="漏桶算法"><a href="#漏桶算法" class="headerlink" title="漏桶算法"></a>漏桶算法</h3><p><strong>具体问题</strong></p>
<p>网站的访问ip中，找出进行频繁连接的ip，并对这些ip的访问频率进行限制。</p>
<p><strong>解决方案</strong></p>
<p>Leak Bucket / Token Bucket</p>
<p><strong>学习资料</strong></p>
<p><a href="http://en.wikipedia.org/wiki/Leaky_bucket" target="_blank" rel="noopener">http://en.wikipedia.org/wiki/Leaky_bucket</a></p>
<p><strong>概述</strong></p>
<p><strong>将上述的寻找频繁访问ip的问题提升到一个更高的抽象层次，就是网站的流量控制。Leaky Bucket就是一种可以辅助实现流量控制的算法。</strong></p>
<p>在我看来，Leaky Bucket是一个抽象层次略高的算法。它的作用，是通过一种模型（即桶），建立了一种合理地判断流量是否异常的算法。</p>
<p>至于在判断出异常流量后，要触发怎样的操作——抛弃？放入等待队列暂缓发送？——仍然要交给算法的实现者根据具体需求作出选择。这并不是Leaky Bucket的管辖范畴。</p>
<p>根据wiki上的介绍，Leaky Bucket实际上有两种不同的含义。</p>
<p>1）as a meter（作为计量工具）</p>
<p>2）as a queue（作为调度队列）</p>
<p>其中，第一种含义和Token Bucket是等价的，只是表述的角度不同。更有趣的是，第二种含义其实是第一种的特例。这些对比和区别在后面再谈，先整体看一下Leaky Bucket。</p>
<p><strong>Leaky Bucket整体思想</strong></p>
<p>Leaky Bucket的核心抽象模型就如字面意思：一个会漏水的桶。</p>
<p><img src="http://blog.51cto.com/attachment/201205/223552670.jpg" alt="Alt text"></p>
<p>如图，桶本身具有一个<strong>恒定的速率</strong>往下漏水，而上方<strong>时快时慢</strong>地会有水进入桶中。当桶还未满时，上方的水可以加入。一旦水满，上方的水就无法加入了。桶满正是算法中的一个的关键触发条件（即流量异常判断成立的条件）。而此条件下如何处理上方欲留下的水，则有了下面两种常见的方式。</p>
<p><strong>Traffic Shaping和Traffic Policing</strong></p>
<p>在桶满水之后，常见的两种处理方式为：</p>
<p>1）暂时拦截住上方水的向下流动，等待桶中的一部分水漏走后，再放行上方水。</p>
<p>2）溢出的上方水直接抛弃。</p>
<p>将水看作网络通信中数据包的抽象，则</p>
<p>方式1起到的效果称为Traffic Shaping，</p>
<p>方式2起到的效果称为Traffic Policing。</p>
<p>由此可见，Traffic Shaping的核心理念是“等待”，Traffic Policing的核心理念是“丢弃”。它们是两种常见的流速控制方法。</p>
<p>（<a href="http://en.wikipedia.org/wiki/Traffic_shaping" target="_blank" rel="noopener">http://en.wikipedia.org/wiki/Traffic_shaping</a>，<a href="http://en.wikipedia.org/wiki/Traffic_policing" target="_blank" rel="noopener">http://en.wikipedia.org/wiki/Traffic_policing</a>）</p>
<p><strong>算法所需的参数</strong></p>
<p>现在，再回顾一下上面的图，可以看出算法只需要两个参数：</p>
<p>1）桶漏水的速率</p>
<p>2）桶的大小</p>
<p>核心：</p>
<p>利用桶模型判断何时的流量达到异常了</p>
<p>外延：</p>
<p>1）流量异常时的处理方法：traffic policing v.s. traffic shaping</p>
<p>2）处理的数据包是否定长：定长 v.s. 变长</p>
<p>3）桶的大小是否等同于每个tick放行的水量：as a queue v.s. as a meter</p>
<p><strong>总结</strong></p>
<p>回头再看，其实Leaky Bucket是一个很简单的想法，在处理流量控制上也能有不错的效果。wiki上的资料非常繁复，看了我一个下午。其实更多的是在大家运用这个词时的情景多种多样，而没有很好地叙述出算法的核心和外延。</p>
<p>我这里做学习笔记，其实主要也是为了理清自己在学习Leaky Bucket时的混乱，试图真正搞清楚哪些是核心，哪些是外延。</p>
<p><strong>注意事项</strong></p>
<p>在学习的过程中，我发现网上所有的中文资料在谈及Leaky Bucket（漏桶）和Token Bucket（令牌桶）算法时，都是把漏桶看作wiki解释中的第二种。所以，以上文章里的“漏桶”和本文的“Leaky Bucket”并不等价。</p>
<p>我个人倒是并不反对用漏桶来指代wiki的第二种解释，因为这样就可以明确区分出“漏桶”和“令牌桶”。但是，在这种解释下，我们需要牢记，“漏桶”就只是“令牌桶”的一个特例而已了。</p>
<h4 id="令牌桶算法"><a href="#令牌桶算法" class="headerlink" title="令牌桶算法"></a>令牌桶算法</h4><p><img src="C:\Users\tony\Desktop\2323.png" alt=""></p>
<p>令牌桶算法基于这样的场景的模拟：<br> 有一个装有token且token数量固定的桶，token添加的速率时固定的，当有请求来(或者数据包到达)，会检查下桶中是否包含足够多的token(一个请求可能需要多个token)。对于数据包而言，数据包的长度等同于需要获取的token数量。即从桶中消费token，若token数量足够，则消费掉，不够则根据不同的策略处理(阻塞当前或提前消费等)。</p>
<h3 id="Guava-Ratelimiter实现"><a href="#Guava-Ratelimiter实现" class="headerlink" title="Guava Ratelimiter实现"></a>Guava Ratelimiter实现</h3><p>Guava实现更接近于令牌桶算法：将一秒钟切割为令牌数的时间片段，每个时间片段等同于一个token。</p>
<p>关键变量：</p>
<ul>
<li><code>nextFreeTicketMicros</code>：表示下一次允许补充许可的时间(时刻)。这个变量的解释比较拗口，看下面流程会比较清晰</li>
<li><code>maxPermits</code>：最大许可数</li>
<li><code>storedPermits</code>：存储的许可数，数量不能超过最大许可数</li>
</ul>
<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p>这里有一个关键方法(重)同步方法，在初始化以及获取操作时都会用到：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void resync(long nowMicros) &#123;</span><br><span class="line">  // if nextFreeTicket is in the past, resync to now</span><br><span class="line">  if (nowMicros &gt; nextFreeTicketMicros) &#123;</span><br><span class="line">    double newPermits = (nowMicros - nextFreeTicketMicros) / coolDownIntervalMicros();</span><br><span class="line">    storedPermits = min(maxPermits, storedPermits + newPermits);</span><br><span class="line">    nextFreeTicketMicros = nowMicros;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果当前时间(不是时刻，而是自创建起所流经的时间，下同)超过了上一次所设定的<code>nextFreeTicketMicros</code>时间，则会重新进行同步：</p>
<ol>
<li>通过计算上一次设定<code>nextFreeTicketMicros</code>到当前时刻的时间差获取新增的可用许可数；</li>
<li>计算可用的许可数：如果新增的许可数+原有的许可数小于最大许可数，则存储的许可数增加新增的数量，否则同步为最大许可数；</li>
<li>同步下一次允许补充许可时间为当前时间</li>
</ol>
<p><strong>初始化</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">static RateLimiter create(SleepingStopwatch stopwatch, double permitsPerSecond) &#123;</span><br><span class="line">  RateLimiter rateLimiter = new SmoothBursty(stopwatch, 1.0 /* maxBurstSeconds */);</span><br><span class="line">  rateLimiter.setRate(permitsPerSecond);</span><br><span class="line">  return rateLimiter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里使用一个<code>StopWatch</code>来计时，主要是获取自限速器创建所流经的时间。<br> 初始化关键变量(其实就是通过<code>resync方法来实现主要逻辑的</code>)：<br> nextFreeTicketMicros为当前时间；maxPermits为传入的每秒允许的许可数；storedPermits则为0</p>
<p><img src="https:////upload-images.jianshu.io/upload_images/2121202-e978395e51b3d0c3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp" alt="img"></p>
<p>初始化</p>
<p><strong>获取许可(acquire)</strong></p>
<blockquote>
<p>获取一定数量的许可，如果获取不到，则阻塞相应时间，然后获取相应许可。并返回当前操作所等待的时间。</p>
</blockquote>
<ol>
<li>尝试<code>resync</code>操作</li>
<li>返回值所需等待时间设置为min(<code>nextFreeTicketMicros</code>-nowMicros,0)</li>
<li>实际消耗的许可数：min(请求许可数,存储许可数中的小值)；</li>
<li>需要刷新获取的许可数(<code>freshPermits</code>)：请求许可数-实际消耗许可数</li>
<li>等待时间(<code>waitMicros</code>)：需要刷新获取的许可数(<code>freshPermits</code>)*每个许可数所需时间</li>
<li>下一次允许补充许可时间(<code>nextFreeTicketMicros</code>)同步为：nextFreeTicketMicros+=waitMicros</li>
<li>更新剩余存储的许可数：存储许可数-本次实际消耗许可数</li>
</ol>
<p>根据<code>resync</code>方法条件：<code>if (nowMicros &gt; nextFreeTicketMicros)</code>不难发现，如果申请获取的许可数多于剩余可分配的许可数，更新后的<code>nextFreeTicketMicros</code>时间会超过<code>nowMicros</code>，但是当前请求所需等待时间为0。即对于超量许可申请(大于当前可提供的许可数)，等待操作是在下一次请求时才会发生。通俗点说就是：前人挖坑后人跳。</p>
<p>当<code>nextFreeTicketMicros</code>早于当前时间，且许可数足够的情况：</p>
<p><img src="https:////upload-images.jianshu.io/upload_images/2121202-b60565b4e4579927.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp" alt="img"></p>
<p>nextFreeTicketMicros早于nowMicros且许可足够</p>
<p>当<code>nextFreeTicketMicros</code>早于当前，但是许可数不够的情况：</p>
<p><img src="https:////upload-images.jianshu.io/upload_images/2121202-b6953207d57818bb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp" alt="img"></p>
<p>nextFreeTicketMicros早于nowMicros但许可不足</p>
<p>当<code>nextFreeTicketMicros</code>晚于当前时间，主要是阻塞时间计算，许可数分发以及时间计算等同上两场景。</p>
<p><strong>尝试获取许可(tryAcquire)</strong><br> 如果<code>nextFreeTicketMicros</code>-<code>timeout</code>&lt;=<code>nowMicros</code>，说明经过超时时间内也不会有一个许可可以分配(按上描述，只要有许可，就可用分配，无论申请的数量有多少)，则tryAcquire操作直接返回false。否则按照acquire操作流程获取许可信息。</p>
<p><strong>预热(warmingup)</strong><br> 首先申请一个容量为100(每秒)的限流器，然后多线程并发获取许可，并发数量为20，且每个线程只获取一次。<br> 附上测试代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public void testCurrent()&#123;</span><br><span class="line">  RateLimiter rateLimiter = RateLimiter.create(100);</span><br><span class="line">  ExecutorService executorService = Executors.newFixedThreadPool(100);</span><br><span class="line">  Runnable runnable = ()-&gt;&#123;</span><br><span class="line">    if(!rateLimiter.tryAcquire(1,100,TimeUnit.MILLISECONDS))&#123;</span><br><span class="line">      System.out.println(&quot;F&quot;+Thread.currentThread().getName());</span><br><span class="line">    &#125;else &#123;</span><br><span class="line">      System.out.println(&quot;A&quot;+Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  for (int i = 0; i &lt; 20; i++) &#123;</span><br><span class="line">    executorService.execute(runnable);</span><br><span class="line">  &#125;</span><br><span class="line">  try &#123;</span><br><span class="line">    executorService.awaitTermination(1,TimeUnit.SECONDS);</span><br><span class="line">  &#125; catch (InterruptedException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>按上算法描述应当不会出现<code>F</code>开头的输出，但是实际却发现20次输出基本有小半数的尝试获取失败：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">1489453467102 pool-1-thread-1</span><br><span class="line">1489453467102 pool-1-thread-2</span><br><span class="line">1489453467104 pool-1-thread-3</span><br><span class="line">1489453467104 pool-1-thread-4</span><br><span class="line">1489453467105 pool-1-thread-5</span><br><span class="line">1489453467105 pool-1-thread-6</span><br><span class="line">1489453467105 pool-1-thread-7</span><br><span class="line">1489453467107 pool-1-thread-8</span><br><span class="line">1489453467107 pool-1-thread-9</span><br><span class="line">F 1489453467108 pool-1-thread-15</span><br><span class="line">F 1489453467108 pool-1-thread-16</span><br><span class="line">F 1489453467109 pool-1-thread-17</span><br><span class="line">F 1489453467109 pool-1-thread-18</span><br><span class="line">F 1489453467109 pool-1-thread-19</span><br><span class="line">F 1489453467109 pool-1-thread-20</span><br><span class="line">1489453467219 pool-1-thread-10</span><br><span class="line">1489453467239 pool-1-thread-11</span><br><span class="line">1489453467259 pool-1-thread-12</span><br><span class="line">1489453467274 pool-1-thread-13</span><br><span class="line">1489453467297 pool-1-thread-14</span><br></pre></td></tr></table></figure>
<p>问题来自于初始化时，<code>storedPermits</code>存储的许可数为0，而第一个线程进行获取时，离初始时时间非常近，导致第一个线程获取许可后，存储的可用许可数并非为声明的最大许可数，从而导致后续线程尝试获取几次后会耗尽存储的许可数，继而导致<code>tryAcquire</code>操作失败。</p>
<h3 id="Guava-RateLimiter详解2"><a href="#Guava-RateLimiter详解2" class="headerlink" title="Guava-RateLimiter详解2"></a>Guava-RateLimiter详解2</h3><p>常用的限流算法有漏桶算法和令牌桶算法，guava的RateLimiter使用的是令牌桶算法，也就是以固定的频率向桶中放入令牌，例如一秒钟10枚令牌，实际业务在每次响应请求之前都从桶中获取令牌，只有取到令牌的请求才会被成功响应，获取的方式有两种：阻塞等待令牌或者取不到立即返回失败.</p>
<p>本次实战，我们用的是guava的RateLimiter，场景是spring mvc在处理请求时候，从桶中申请令牌，申请到了就成功响应，申请不到时直接返回失败。</p>
<h3 id="实例一"><a href="#实例一" class="headerlink" title="实例一"></a>实例一</h3><p>1、添加guava jar包</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;com.google.guava&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;guava&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;18.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<p>2、AccessLimitService.java 限流服务封装到一个类中AccessLimitService，提供tryAcquire()方法，用来尝试获取令牌，返回true表示获取到</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class AccessLimitService &#123;</span><br><span class="line"></span><br><span class="line">    //每秒只发出5个令牌</span><br><span class="line">    RateLimiter rateLimiter = RateLimiter.create(5.0);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 尝试获取令牌</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public boolean tryAcquire()&#123;</span><br><span class="line">        return rateLimiter.tryAcquire();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3、Controller层每次收到请求的时候都尝试去获取令牌，获取成功和失败打印不同的信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">@Controller</span><br><span class="line">public class HelloController &#123;</span><br><span class="line"></span><br><span class="line">    private static SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private AccessLimitService accessLimitService;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(&quot;/access&quot;)</span><br><span class="line">    @ResponseBody</span><br><span class="line">    public String access()&#123;</span><br><span class="line">        //尝试获取令牌</span><br><span class="line">        if(accessLimitService.tryAcquire())&#123;</span><br><span class="line">            //模拟业务执行500毫秒</span><br><span class="line">            try &#123;</span><br><span class="line">                Thread.sleep(500);</span><br><span class="line">            &#125;catch (InterruptedException e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            return &quot;aceess success [&quot; + sdf.format(new Date()) + &quot;]&quot;;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            return &quot;aceess limit [&quot; + sdf.format(new Date()) + &quot;]&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>4、测试：十个线程并发访问接口</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">public class AccessClient &#123;</span><br><span class="line">    ExecutorService fixedThreadPool = Executors.newFixedThreadPool(10);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * get请求</span><br><span class="line">     * @param realUrl</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public static String sendGet(URL realUrl) &#123;</span><br><span class="line">        String result = &quot;&quot;;</span><br><span class="line">        BufferedReader in = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            // 打开和URL之间的连接</span><br><span class="line">            URLConnection connection = realUrl.openConnection();</span><br><span class="line">            // 设置通用的请求属性</span><br><span class="line">            connection.setRequestProperty(&quot;accept&quot;, &quot;*/*&quot;);</span><br><span class="line">            connection.setRequestProperty(&quot;connection&quot;, &quot;Keep-Alive&quot;);</span><br><span class="line">            connection.setRequestProperty(&quot;user-agent&quot;,</span><br><span class="line">                    &quot;Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1;SV1)&quot;);</span><br><span class="line">            // 建立实际的连接</span><br><span class="line">            connection.connect();</span><br><span class="line"></span><br><span class="line">            // 定义 BufferedReader输入流来读取URL的响应</span><br><span class="line">            in = new BufferedReader(new InputStreamReader(</span><br><span class="line">                    connection.getInputStream()));</span><br><span class="line">            String line;</span><br><span class="line">            while ((line = in.readLine()) != null) &#123;</span><br><span class="line">                result += line;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            System.out.println(&quot;发送GET请求出现异常！&quot; + e);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        // 使用finally块来关闭输入流</span><br><span class="line">        finally &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                if (in != null) &#123;</span><br><span class="line">                    in.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (Exception e2) &#123;</span><br><span class="line">                e2.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public void access() throws Exception&#123;</span><br><span class="line">        final URL url = new URL(&quot;http://localhost:8080/guavalimitdemo/access&quot;);</span><br><span class="line"></span><br><span class="line">        for(int i=0;i&lt;10;i++) &#123;</span><br><span class="line">            fixedThreadPool.submit(new Runnable() &#123;</span><br><span class="line">                public void run() &#123;</span><br><span class="line">                    System.out.println(sendGet(url));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        fixedThreadPool.shutdown();</span><br><span class="line">        fixedThreadPool.awaitTermination(Long.MAX_VALUE, TimeUnit.SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception&#123;</span><br><span class="line">        AccessClient accessClient = new AccessClient();</span><br><span class="line">        accessClient.access();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>部分请求由于获取的令牌可以成功执行，其余请求没有拿到令牌，我们可以根据实际业务来做区分处理。还有一点要注意，我们通过RateLimiter.create(5.0)配置的是每一秒5枚令牌，但是限流的时候发出的是6枚，改用其他值验证，也是实际的比配置的大1。</p>
</blockquote>
<p>以上就是快速实现限流的实战过程，此处仅是单进程服务的限流，而实际的分布式服务中会考虑更多因素，会复杂很多。</p>
<hr>
<h3 id="RateLimiter方法摘要"><a href="#RateLimiter方法摘要" class="headerlink" title="RateLimiter方法摘要"></a>RateLimiter方法摘要</h3><table>
<thead>
<tr>
<th>修饰符和类型</th>
<th>方法和描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>double</td>
<td><strong>acquire()</strong> 从RateLimiter获取一个许可，该方法会被阻塞直到获取到请求</td>
</tr>
<tr>
<td>double</td>
<td><strong>acquire(int permits)</strong>从RateLimiter获取指定许可数，该方法会被阻塞直到获取到请求</td>
</tr>
<tr>
<td>static RateLimiter</td>
<td>create(double permitsPerSecond)根据指定的稳定吞吐率创建RateLimiter，这里的吞吐率是指每秒多少许可数（通常是指QPS，每秒多少查询）</td>
</tr>
<tr>
<td>static RateLimiter</td>
<td><strong>create(double permitsPerSecond, long warmupPeriod, TimeUnit unit)</strong>根据指定的稳定吞吐率和预热期来创建RateLimiter，这里的吞吐率是指每秒多少许可数（通常是指QPS，每秒多少个请求量），在这段预热时间内，RateLimiter每秒分配的许可数会平稳地增长直到预热期结束时达到其最大速率。（只要存在足够请求数来使其饱和）</td>
</tr>
<tr>
<td>double</td>
<td><strong>getRate()</strong>返回RateLimiter 配置中的稳定速率，该速率单位是每秒多少许可数</td>
</tr>
<tr>
<td>void</td>
<td><strong>setRate(double permitsPerSecond)</strong>更新RateLimite的稳定速率，参数permitsPerSecond 由构造RateLimiter的工厂方法提供。</td>
</tr>
<tr>
<td>String</td>
<td>toString()返回对象的字符表现形式</td>
</tr>
<tr>
<td>boolean</td>
<td><strong>tryAcquire()</strong>从RateLimiter 获取许可，如果该许可可以在无延迟下的情况下立即获取得到的话</td>
</tr>
<tr>
<td>boolean</td>
<td><strong>tryAcquire(int permits)</strong>从RateLimiter 获取许可数，如果该许可数可以在无延迟下的情况下立即获取得到的话</td>
</tr>
<tr>
<td>boolean</td>
<td><strong>tryAcquire(int permits, long timeout, TimeUnit unit)</strong>从RateLimiter 获取指定许可数如果该许可数可以在不超过timeout的时间内获取得到的话，或者如果无法在timeout 过期之前获取得到许可数的话，那么立即返回false （无需等待）</td>
</tr>
<tr>
<td>boolean</td>
<td><strong>tryAcquire(long timeout, TimeUnit unit)</strong>从RateLimiter 获取许可如果该许可可以在不超过timeout的时间内获取得到的话，或者如果无法在timeout 过期之前获取得到许可的话，那么立即返回false（无需等待）</td>
</tr>
</tbody>
</table>
<ul>
<li>举例来说明如何使用RateLimiter，想象下我们需要处理一个任务列表，但我们不希望每秒的任务提交超过两个：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//速率是每秒两个许可</span><br><span class="line">final RateLimiter rateLimiter = RateLimiter.create(2.0);</span><br><span class="line">void submitTasks(List tasks, Executor executor) &#123;</span><br><span class="line">    for (Runnable task : tasks) &#123;</span><br><span class="line">        rateLimiter.acquire(); // 也许需要等待</span><br><span class="line">        executor.execute(task);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>官方文档：<a href="https://link.jianshu.com/?t=http%3A%2F%2Fifeve.com%2Fguava-ratelimiter" target="_blank" rel="noopener">http://ifeve.com/guava-ratelimiter</a></p>
<h3 id="实例二"><a href="#实例二" class="headerlink" title="实例二"></a>实例二</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">package com.didispace.demo;</span><br><span class="line"></span><br><span class="line">import com.google.common.util.concurrent.RateLimiter;</span><br><span class="line"></span><br><span class="line">import java.util.Random;</span><br><span class="line">import java.util.concurrent.CountDownLatch;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Created by daizhao.</span><br><span class="line"> * User: tony</span><br><span class="line"> * Date: 2018-10-30</span><br><span class="line"> * Time: 10:01</span><br><span class="line"> * info: RateLimiter限流技术(令牌桶算法)</span><br><span class="line"> */</span><br><span class="line">public class TestRateLimiter &#123;</span><br><span class="line">    //每秒只发出10个令牌</span><br><span class="line">    RateLimiter rateLimiter = RateLimiter.create(10);</span><br><span class="line"></span><br><span class="line">    public void sendRequest() &#123;</span><br><span class="line">        if (rateLimiter.tryAcquire()) &#123;//获取令牌成功</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot;请求成功&quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot;请求失败&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        TestRateLimiter testRateLimiter = new TestRateLimiter();</span><br><span class="line">        CountDownLatch countDownLatch = new CountDownLatch(1);//发令枪</span><br><span class="line">        Random random = new Random(10);</span><br><span class="line">        for (int i = 0; i &lt; 20; i++) &#123;</span><br><span class="line">            new Thread(() -&gt; &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    countDownLatch.await();//所有线程阻塞在此</span><br><span class="line">                    Thread.sleep(random.nextInt(1000));</span><br><span class="line">                    testRateLimiter.sendRequest();</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, i + &quot;tt&quot;).start();</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch.countDown();//所有线程同时开启</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

        
        </div>
        <footer class="article-footer">
            
    <div class="article-tag">
        <i class="fa fa-tag"></i>
        <a class="tag-link" href="/blog/tags/秒杀/">秒杀</a>, <a class="tag-link" href="/blog/tags/限流/">限流</a>, <a class="tag-link" href="/blog/tags/高并发/">高并发</a>
    </div>

			<!-- -->
			<div class="share-container">



</div>

    <a data-url="https://pentakillandquadrakill.gitee.io/blog/2018/10/30/Guava-RateLimiter秒杀限流技术详解/" data-id="cjnv5hzhp0001wous1vtcvu94" class="article-share-link"><i class="fa fa-share"></i>Partager</a>
<script>
    (function ($) {
        // Prevent duplicate binding
        if (typeof(__SHARE_BUTTON_BINDED__) === 'undefined' || !__SHARE_BUTTON_BINDED__) {
            __SHARE_BUTTON_BINDED__ = true;
        } else {
            return;
        }
        $('body').on('click', function() {
            $('.article-share-box.on').removeClass('on');
        }).on('click', '.article-share-link', function(e) {
            e.stopPropagation();

            var $this = $(this),
                url = $this.attr('data-url'),
                encodedUrl = encodeURIComponent(url),
                id = 'article-share-box-' + $this.attr('data-id'),
                offset = $this.offset(),
                box;

            if ($('#' + id).length) {
                box = $('#' + id);

                if (box.hasClass('on')){
                    box.removeClass('on');
                    return;
                }
            } else {
                var html = [
                    '<div id="' + id + '" class="article-share-box">',
                        '<input class="article-share-input" value="' + url + '">',
                        '<div class="article-share-links">',
                            '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="fa fa-twitter article-share-twitter" target="_blank" title="Twitter"></a>',
                            '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="fa fa-facebook article-share-facebook" target="_blank" title="Facebook"></a>',
                            '<a href="http://pinterest.com/pin/create/button/?url=' + encodedUrl + '" class="fa fa-pinterest article-share-pinterest" target="_blank" title="Pinterest"></a>',
                            '<a href="https://plus.google.com/share?url=' + encodedUrl + '" class="fa fa-google article-share-google" target="_blank" title="Google+"></a>',
                        '</div>',
                    '</div>'
                ].join('');

              box = $(html);

              $('body').append(box);
            }

            $('.article-share-box.on').hide();

            box.css({
                top: offset.top + 25,
                left: offset.left
            }).addClass('on');

        }).on('click', '.article-share-box', function (e) {
            e.stopPropagation();
        }).on('click', '.article-share-box-input', function () {
            $(this).select();
        }).on('click', '.article-share-box-link', function (e) {
            e.preventDefault();
            e.stopPropagation();

            window.open(this.href, 'article-share-box-window-' + Date.now(), 'width=500,height=450');
        });
    })(jQuery);
</script>

            
    

			
        </footer>
    </div>
    
        
<nav id="article-nav">
    
    
        <a href="/blog/2018/10/26/高并发环境下如何防止订单重复提交/" id="article-nav-older" class="article-nav-link-wrap">
            <strong class="article-nav-caption">Plus ancien</strong>
            <div class="article-nav-title">高并发环境下如何防止订单重复提交</div>
        </a>
    
</nav>


    
</article>


    
    <section id="comments">
    
        <!-- 来必力City版安装代码 -->
<div id="lv-container" data-id="city" data-uid="MTAyMC80MDQzMy8xNjk2MA==">
<script type="text/javascript">
   (function(d, s) {
       var j, e = d.getElementsByTagName(s)[0];

       if (typeof LivereTower === 'function') { return; }

       j = d.createElement(s);
       j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
       j.async = true;

       e.parentNode.insertBefore(j, e);
   })(document, 'script');
</script>
<noscript>为正常使用来必力评论功能请激活JavaScript</noscript>
</div>
<!-- City版安装代码已完成 -->
    
    </section>

</section>
            
                <aside id="sidebar">
   
        
    <div class="widget-wrap">
        <h3 class="widget-title">Récents</h3>
        <div class="widget">
            <ul id="recent-post" class="">
                
                    <li>
                        
                        <div class="item-thumbnail">
                            <a href="/blog/2018/10/30/Guava-RateLimiter秒杀限流技术详解/" class="thumbnail">
    
    
        <span class="thumbnail-image thumbnail-none"></span>
    
</a>

                        </div>
                        
                        <div class="item-inner">
                            <p class="item-category"><a class="article-category-link" href="/blog/categories/Java/">Java</a></p>
                            <p class="item-title"><a href="/blog/2018/10/30/Guava-RateLimiter秒杀限流技术详解/" class="title">Guava-RateLimiter秒杀限流技术详解</a></p>
                            <p class="item-date"><time datetime="2018-10-30T02:26:28.000Z" itemprop="datePublished">2018-10-30</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <div class="item-thumbnail">
                            <a href="/blog/2018/10/26/高并发环境下如何防止订单重复提交/" class="thumbnail">
    
    
        <span class="thumbnail-image thumbnail-none"></span>
    
</a>

                        </div>
                        
                        <div class="item-inner">
                            <p class="item-category"></p>
                            <p class="item-title"><a href="/blog/2018/10/26/高并发环境下如何防止订单重复提交/" class="title">高并发环境下如何防止订单重复提交</a></p>
                            <p class="item-date"><time datetime="2018-10-26T02:54:44.000Z" itemprop="datePublished">2018-10-26</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <div class="item-thumbnail">
                            <a href="/blog/2018/10/16/author测试/" class="thumbnail">
    
    
        <span class="thumbnail-image thumbnail-none"></span>
    
</a>

                        </div>
                        
                        <div class="item-inner">
                            <p class="item-category"><a class="article-category-link" href="/blog/categories/Diary/">Diary</a></p>
                            <p class="item-title"><a href="/blog/2018/10/16/author测试/" class="title">author测试</a></p>
                            <p class="item-date"><time datetime="2018-10-16T02:34:29.000Z" itemprop="datePublished">2018-10-16</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <div class="item-thumbnail">
                            <a href="/blog/2018/10/15/photo测试/" class="thumbnail">
    
    
        <span class="thumbnail-image thumbnail-none"></span>
    
</a>

                        </div>
                        
                        <div class="item-inner">
                            <p class="item-category"><a class="article-category-link" href="/blog/categories/Diary/">Diary</a></p>
                            <p class="item-title"><a href="/blog/2018/10/15/photo测试/" class="title">photo测试</a></p>
                            <p class="item-date"><time datetime="2018-10-15T06:51:42.000Z" itemprop="datePublished">2018-10-15</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <div class="item-thumbnail">
                            <a href="/blog/2018/10/15/draft测试/" class="thumbnail">
    
    
        <span class="thumbnail-image thumbnail-none"></span>
    
</a>

                        </div>
                        
                        <div class="item-inner">
                            <p class="item-category"><a class="article-category-link" href="/blog/categories/Diary/">Diary</a></p>
                            <p class="item-title"><a href="/blog/2018/10/15/draft测试/" class="title">draft测试</a></p>
                            <p class="item-date"><time datetime="2018-10-15T06:49:38.000Z" itemprop="datePublished">2018-10-15</time></p>
                        </div>
                    </li>
                
            </ul>
        </div>
    </div>

    
        
    <div class="widget-wrap">
        <h3 class="widget-title">Catégories</h3>
        <div class="widget">
            <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/blog/categories/Diary/">Diary</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/categories/Java/">Java</a><span class="category-list-count">1</span></li></ul>
        </div>
    </div>

    
        
    <div class="widget-wrap">
        <h3 class="widget-title">Archives</h3>
        <div class="widget">
            <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2018/10/">October 2018</a><span class="archive-list-count">10</span></li></ul>
        </div>
    </div>

    
        
    <div class="widget-wrap">
        <h3 class="widget-title">Tags</h3>
        <div class="widget">
            <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/fsdfds/">fsdfds</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/sdfsdf/">sdfsdf</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/天下一地/">天下一地</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/秒杀/">秒杀</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/组织/">组织</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/限流/">限流</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/高并发/">高并发</a><span class="tag-list-count">1</span></li></ul>
        </div>
    </div>

    
        
    <div class="widget-wrap">
        <h3 class="widget-title">Nuage de tags</h3>
        <div class="widget tagcloud">
            <a href="/blog/tags/fsdfds/" style="font-size: 15px;">fsdfds</a> <a href="/blog/tags/sdfsdf/" style="font-size: 15px;">sdfsdf</a> <a href="/blog/tags/天下一地/" style="font-size: 20px;">天下一地</a> <a href="/blog/tags/秒杀/" style="font-size: 10px;">秒杀</a> <a href="/blog/tags/组织/" style="font-size: 20px;">组织</a> <a href="/blog/tags/限流/" style="font-size: 10px;">限流</a> <a href="/blog/tags/高并发/" style="font-size: 10px;">高并发</a>
        </div>
    </div>

    
        
    <div class="widget-wrap widget-list">
        <h3 class="widget-title">Liens</h3>
        <div class="widget">
            <ul>
                
                    <li>
                        <a href="http://hexo.io">Hexo</a>
                    </li>
                
            </ul>
        </div>
    </div>


    
    <div id="toTop" class="fa fa-angle-up"></div>
</aside>
            
        </div>
        <footer id="footer">
    <div class="outer">
        <div id="footer-info" class="inner">
            &copy; 2018 tuonioooo<br>
            Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>. Theme by <a href="http://github.com/ppoffice">PPOffice</a>
        </div>
    </div>
</footer>
        

    
        <script src="/blog/vendor/lightgallery/js/lightgallery.min.js"></script>
        <script src="/blog/vendor/lightgallery/js/lg-thumbnail.min.js"></script>
        <script src="/blog/vendor/lightgallery/js/lg-pager.min.js"></script>
        <script src="/blog/vendor/lightgallery/js/lg-autoplay.min.js"></script>
        <script src="/blog/vendor/lightgallery/js/lg-fullscreen.min.js"></script>
        <script src="/blog/vendor/lightgallery/js/lg-zoom.min.js"></script>
        <script src="/blog/vendor/lightgallery/js/lg-hash.min.js"></script>
        <script src="/blog/vendor/lightgallery/js/lg-share.min.js"></script>
        <script src="/blog/vendor/lightgallery/js/lg-video.min.js"></script>
    
    



<!-- Custom Scripts -->
<script src="/blog/js/main.js"></script>

    </div>
<style>

.label {
    display: inline;
    margin: 5px;
    padding: .2em .6em .3em 0em;
    line-height: 1;
	font-size: 75%;
    font-weight: bold;
    color: #fff;
    text-align: center;
    white-space: nowrap;
    vertical-align: baseline;
    border-radius: .25em;
}
.label-success {
    background-color: #5cb85c;
}
.label-warning {
    background-color: #f0ad4e;
}
<style>	
</body>
</html>